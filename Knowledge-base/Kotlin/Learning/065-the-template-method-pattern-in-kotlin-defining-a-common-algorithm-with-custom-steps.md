---
title: 065: Kotlin의 템플릿 메서드 패턴: 사용자 지정 단계로 공통 알고리즘 정의
description: 
published: true
date: 2023-02-17T01:32:35.778Z
tags: 
editor: markdown
dateCreated: 2023-02-17T01:32:33.654Z
---

> 이 문서는 **Google Cloud Translation API를 사용해 자동 번역**되었습니다.
어떤 문서는 원문을 읽는게 나을 수도 있습니다.{.is-info}



- [065: The Template Method Pattern in Kotlin: Defining a Common Algorithm with Custom Steps***English** document is available*](/en/Knowledge-base/Kotlin/Learning/065-the-template-method-pattern-in-kotlin-defining-a-common-algorithm-with-custom-steps)
{.links-list}


# Kotlin의 템플릿 메서드 패턴: 사용자 지정 단계로 공통 알고리즘 정의

소프트웨어 엔지니어링에서 템플릿 메서드 패턴은 기본 클래스에서 알고리즘의 프로그램 골격을 정의하지만 해당 하위 클래스가 일부 또는 모든 알고리즘에 대한 구체적인 구현을 제공할 수 있도록 하는 동작 설계 패턴입니다.

템플릿 메서드 패턴은 코드 재사용 및 알고리즘 구조 정의를 위한 강력한 기술이지만 주의해서 사용해야 합니다. 특히, 템플릿 메서드는 단계 측면에서 알고리즘을 정의하는 것이 적절하고 이러한 단계가 서로 다른 하위 클래스에 의해 다르게 구현될 것으로 합리적으로 예상될 수 있는 경우에만 사용해야 합니다.

## 템플릿 메소드 패턴이란?

템플릿 메서드 패턴은 기본 클래스에서 알고리즘의 프로그램 골격을 정의하지만 해당 하위 클래스가 일부 또는 모든 알고리즘에 대한 구체적인 구현을 제공할 수 있도록 하는 동작 디자인 패턴입니다.

템플릿 메서드 패턴은 코드 재사용 및 알고리즘 구조 정의를 위한 강력한 기술이지만 주의해서 사용해야 합니다. 특히, 템플릿 메서드는 단계 측면에서 알고리즘을 정의하는 것이 적절하고 이러한 단계가 서로 다른 하위 클래스에 의해 다르게 구현될 것으로 합리적으로 예상될 수 있는 경우에만 사용해야 합니다.

템플릿 메서드 패턴에서 알고리즘의 단계는 추상이거나 기본 구현이 있는 메서드에서 구현됩니다. 이러한 메서드를 템플릿 메서드라고 합니다. 템플릿 메서드는 알고리즘의 전체 구조를 정의하는 반면 구체적인 구현 세부 정보는 추상적이거나 기본 구현이 있는 메서드에서 제공됩니다.

템플릿 메서드 패턴은 프레임워크에서 알고리즘 또는 애플리케이션의 전체 구조를 정의하는 프레임워크에서 자주 사용되며 구체적인 세부 정보는 프레임워크 사용자가 제공합니다.

## 템플릿 메소드 패턴은 언제 사용하나요?

템플릿 메서드 패턴은 단계 측면에서 알고리즘을 정의하려는 경우와 이러한 단계가 서로 다른 하위 클래스에 의해 다르게 구현될 것으로 합리적으로 예상될 수 있는 경우에 사용해야 합니다.

특히 템플릿 메서드 패턴은 다음과 같은 경우에 유용합니다.

* 일련의 단계로 분해할 수 있는 알고리즘을 정의해야 합니다.

* 서로 다른 하위 클래스는 알고리즘의 하나 이상의 단계를 다르게 구현할 것으로 예상됩니다.

* 단계가 실행되는 순서가 중요합니다.

* 하위 클래스에 영향을 주지 않고 쉽게 변경할 수 있도록 기본 클래스에서 알고리즘의 구현 세부 정보를 캡슐화하려고 합니다.

## 템플릿 메서드 패턴을 구현하는 방법은 무엇입니까?

상속 또는 위임을 사용하여 Kotlin에서 템플릿 메서드 패턴을 구현할 수 있습니다.

### 상속

상속을 사용할 때 기본 클래스는 알고리즘의 전체 구조를 정의하는 반면 구체적인 구현 세부 정보는 하위 클래스에서 제공됩니다.

상속을 사용하여 템플릿 메서드 패턴을 구현하려면 다음을 수행해야 합니다.

* 템플릿 메서드를 포함하는 추상 기본 클래스를 정의합니다.

* 원하는 구현을 제공하기 위해 기본 클래스의 메서드를 재정의하는 구체적인 하위 클래스를 정의합니다.

예를 들어 메시지를 파일에 기록해야 하는 애플리케이션을 생각해 보십시오. 메시지 로깅을 위한 템플릿 메서드를 포함하는 기본 클래스와 원하는 구현을 제공하기 위해 메서드를 재정의하는 구체적인 하위 클래스를 정의할 수 있습니다.

```kotlin
abstract class Logger {
    fun log(message: String) {
        openFile()
        writeFile(message)
        closeFile()
    }

    abstract fun openFile()
    abstract fun writeFile(message: String)
    abstract fun closeFile()
}

class FileLogger: Logger() {
    override fun openFile() {
        // ...
    }

    override fun writeFile(message: String) {
        // ...
    }

    override fun closeFile() {
        // ...
    }
}

class ConsoleLogger: Logger() {
    override fun openFile() {
        // ...
    }

    override fun writeFile(message: String) {
        // ...
    }

    override fun closeFile() {
        // ...
    }
}
```

위의 예에서 기본 클래스는 알고리즘의 전체 구조를 포함하는 템플릿 메서드 ```log()```를 정의합니다. ```log()``` 메소드는 ```openFile()```, ```writeFile()``` 및 ```closeFile()``` 메소드를 호출합니다. 하위 클래스.

### 위임

위임을 사용할 때 기본 클래스는 알고리즘의 전체 구조를 정의하는 반면 구체적인 구현 세부 정보는 위임 개체에서 제공됩니다.

위임을 사용하여 템플릿 메서드 패턴을 구현하려면 다음을 수행해야 합니다.

* 템플릿 메서드를 포함하는 기본 클래스를 정의합니다.

* 템플릿 메서드에 의해 호출될 메서드를 포함하는 대리자 클래스를 정의합니다.

* 기본 클래스에서 대리자 클래스의 인스턴스를 만들고 템플릿 메서드에 전달합니다.

예를 들어 메시지를 파일에 기록해야 하는 애플리케이션을 생각해 보십시오. 메시지 로깅을 위한 템플릿 메서드를 포함하는 기본 클래스와 템플릿 메서드에서 호출할 메서드를 포함하는 대리자 클래스를 정의할 수 있습니다.

```kotlin
class Logger(val delegate: LoggerDelegate) {
    fun log(message: String) {
        delegate.openFile()
        delegate.writeFile(message)
        delegate.closeFile()
    }
}

class FileLoggerDelegate: LoggerDelegate {
    override fun openFile() {
        // ...
    }

    override fun writeFile(message: String) {
        // ...
    }

    override fun closeFile() {
        // ...
    }
}

class ConsoleLoggerDelegate: LoggerDelegate {
    override fun openFile() {
        // ...
    }

    override fun writeFile(message: String) {
        // ...
    }

    override fun closeFile() {
        // ...
    }
}
```

위의 예에서 기본 클래스는 알고리즘의 전체 구조를 포함하는 템플릿 메서드 ```log()```를 정의합니다. ```log()``` 메소드는 위임 객체의 ```openFile()```, ```writeFile()``` 및 ```closeFile()``` 메소드를 호출합니다. 구체적인 구현 세부 정보는 대리자 클래스에서 제공합니다.

## 템플릿 메소드 패턴의 장점

템플릿 메서드 패턴에는 다음과 같은 이점이 있습니다.

* 알고리즘의 구현 세부 사항을 기본 클래스에 캡슐화하므로 하위 클래스에 영향을 주지 않고 쉽게 변경할 수 있습니다.

* 기본 클래스에서 알고리즘의 전체 구조를 정의하는 동시에 하위 클래스에서 일부 또는 모든 단계에 대한 구체적인 구현을 제공할 수 있습니다.

* 모든 하위 클래스에서 재사용할 수 있는 기본 클래스에서 공통 코드를 정의할 수 있도록 하여 코드 재사용을 촉진합니다.

* 기존 코드에 영향을 주지 않고 알고리즘에 새로운 단계를 추가할 수 있어 확장이 용이합니다.

## 템플릿 메소드 패턴의 단점

템플릿 메서드 패턴에는 다음과 같은 단점이 있습니다.

* 동일한 알고리즘이 여러 곳에서 약간의 변형만 필요한 경우 코드 중복이 발생할 수 있습니다. 이러한 경우 일반적으로 공통 코드를 별도의 함수 또는 메서드로 추출하는 것이 좋습니다.

* 알고리즘이 너무 복잡하면 코드를 이해하고 유지하기가 더 어려워질 수 있습니다. 이러한 경우 일반적으로 코드를 리팩터링하여 읽기 쉽고 유지 관리하기 쉽게 만드는 것이 좋습니다.

## 결론

템플릿 메서드 패턴은 코드 재사용 및 알고리즘 구조 정의를 위한 강력한 기술이지만 주의해서 사용해야 합니다. 특히, 템플릿 메서드는 단계 측면에서 알고리즘을 정의하는 것이 적절하고 이러한 단계가 서로 다른 하위 클래스에 의해 다르게 구현될 것으로 합리적으로 예상될 수 있는 경우에만 사용해야 합니다.