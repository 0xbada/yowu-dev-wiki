---
title: 스프링 부트와 하이버네이트 트랜잭션
description: 
published: true
date: 2023-02-07T23:32:35.330Z
tags: 
editor: markdown
dateCreated: 2023-02-07T23:32:29.483Z
---

> 이 문서는 **Google Cloud Translation API를 사용해 자동 번역**되었습니다.
어떤 문서는 원문을 읽는게 나을 수도 있습니다.{.is-info}



- [Spring Boot and Hibernate Transactions***English** document is available*](/en/Knowledge-base/Spring-Boot/spring-boot-and-hibernate-transactions)
{.links-list}


# 스프링 부트와 하이버네이트 트랜잭션

트랜잭션은 모든 데이터베이스 기반 애플리케이션의 기본적인 부분입니다. 간단히 말해서 트랜잭션은 하나 이상의 데이터베이스 작업을 원자 단위로 묶는 방법입니다. 모든 작업이 성공하거나 아무 작업도 수행하지 않습니다.

트랜잭션을 사용하면 다음과 같은 많은 이점이 있습니다.

- 데이터 일관성 보장: 트랜잭션의 작업 중 하나라도 실패하면 전체 트랜잭션이 롤백되고 데이터베이스는 원래 상태로 유지됩니다.
- 더 나은 성능 허용: 트랜잭션 내의 데이터베이스 작업을 일괄 처리할 수 있으므로 데이터베이스 왕복 횟수가 줄어들고 성능이 향상될 수 있습니다.
- 동시성 향상: 트랜잭션을 서로 격리하여 하나의 트랜잭션이 다른 트랜잭션을 방해하는 것을 방지할 수 있습니다.

이 기사에서는 Spring Boot 및 Hibernate로 트랜잭션을 사용하는 방법을 살펴보겠습니다. 다양한 유형의 트랜잭션에 대한 간략한 개요부터 시작한 다음 몇 가지 코드 예제를 살펴보겠습니다.

## 거래 유형

트랜잭션에는 로컬 및 글로벌의 두 가지 주요 유형이 있습니다.

로컬 트랜잭션은 데이터베이스와 같은 단일 리소스에서 관리하는 트랜잭션입니다. 로컬 트랜잭션에서 모든 작업은 동일한 데이터베이스에서 수행되어야 합니다. 작업 중 하나라도 실패하면 전체 트랜잭션이 롤백되고 데이터베이스는 원래 상태로 유지됩니다.

전역 트랜잭션은 데이터베이스 및 메시지 대기열과 같은 여러 리소스에 의해 관리되는 트랜잭션입니다. 글로벌 트랜잭션은 로컬 트랜잭션보다 복잡하지만 리소스 중 하나가 실패하더라도 전체 트랜잭션을 롤백할 수 있는 이점을 제공합니다.

## 스프링 부트로 트랜잭션 사용

Spring Boot는 트랜잭션에 대한 최고 수준의 지원을 제공합니다. 실제로 트랜잭션은 데이터베이스가 트랜잭션에 대해 구성되지 않았음을 감지하면 Spring Boot 애플리케이션이 시작되지 않을 정도로 중요합니다.

Spring Boot에서 트랜잭션을 구성할 때 염두에 두어야 할 세 가지 사항이 있습니다.

- @Transactional 어노테이션: 이 어노테이션은 트랜잭션에서 실행되어야 하는 메소드를 표시하는 데 사용됩니다.
- PlatformTransactionManager: 트랜잭션을 실제로 관리하는 구성 요소입니다. Spring Boot는 데이터베이스를 사용하고 있음을 감지하면 자동으로 PlatformTransactionManager 빈을 구성합니다.
- 트랜잭션 격리 수준: 트랜잭션에 대해 원하는 격리 수준입니다. 서로 다른 수준의 격리는 데이터의 일관성에 대해 서로 다른 보장을 제공합니다.

Spring Boot에서 트랜잭션을 구성하는 가장 일반적인 방법은 @Transactional 주석을 사용하는 것입니다. 이 주석은 클래스 또는 메서드에 추가할 수 있습니다. 클래스에 추가되면 클래스의 모든 메서드에 적용됩니다. 메서드에 추가하면 해당 메서드에만 적용됩니다.

@Transactional 주석에는 해당 동작을 사용자 지정하는 데 사용할 수 있는 몇 가지 선택적 매개 변수가 있습니다. 이들 중 가장 중요한 것은 격리 수준입니다. 격리 수준은 데이터베이스가 ACID 속성을 얼마나 엄격하게 적용하는지 제어하는 데 사용됩니다.

일반적으로 사용되는 네 가지 격리 수준이 있습니다.

- READ UNCOMMITTED: 가장 덜 엄격한 격리 수준입니다. 동시 트랜잭션이 다른 트랜잭션에 의해 커밋되지 않은 데이터를 읽을 수 있습니다. 이로 인해 데이터 불일치가 발생할 수 있지만 최상의 성능을 제공합니다.
- READ COMMITTED: 이 격리 수준은 READ UNCOMMITTED보다 엄격합니다. 동시 트랜잭션은 다른 트랜잭션이 커밋한 데이터만 읽을 수 있습니다. 이렇게 하면 데이터 불일치가 방지되지만 성능 문제가 발생할 수 있습니다.
- REPEATABLE READ: 이 격리 수준은 READ COMMITTED보다 훨씬 더 엄격합니다. 동시 트랜잭션은 다른 트랜잭션이 커밋한 데이터만 읽을 수 있으며 다른 트랜잭션이 수정한 데이터는 읽을 수 없습니다. 이것은 최상의 데이터 일관성을 제공하지만 성능 문제를 일으킬 수 있습니다.
- SERIALIZABLE: 가장 엄격한 격리 수준입니다. 동시 트랜잭션이 다른 트랜잭션에 의해 수정된 데이터를 읽거나 쓰는 것을 방지합니다. 이것은 최상의 데이터 일관성을 제공하지만 성능 문제를 일으킬 수 있습니다.

애플리케이션에 적합한 격리 수준을 선택하는 것이 중요합니다. 너무 엄격한 격리 수준을 선택하면 성능 문제가 발생할 수 있습니다. 너무 느슨한 격리 수준을 선택하면 데이터 불일치가 나타날 수 있습니다.

## Hibernate로 트랜잭션 사용하기

Hibernate는 Spring과 함께 자주 사용되는 대중적인 ORM 도구입니다. Hibernate는 또한 트랜잭션을 지원하고 트랜잭션을 구성하는 몇 가지 다른 방법을 제공합니다.

Hibernate에서 트랜잭션을 구성하는 가장 일반적인 방법은 @Transactional 주석을 사용하는 것입니다. 이 주석은 클래스 또는 메서드에 추가할 수 있습니다. 클래스에 추가되면 클래스의 모든 메서드에 적용됩니다. 메서드에 추가하면 해당 메서드에만 적용됩니다.

@Transactional 주석에는 해당 동작을 사용자 지정하는 데 사용할 수 있는 몇 가지 선택적 매개 변수가 있습니다. 이들 중 가장 중요한 것은 격리 수준입니다. 격리 수준은 데이터베이스가 ACID 속성을 얼마나 엄격하게 적용하는지 제어하는 데 사용됩니다.

Hibernate는 프로그래밍 방식의 트랜잭션도 지원합니다. 이는 주석을 사용하지 않고 코드에서 트랜잭션을 구성할 수 있음을 의미합니다. 이것은 코드를 이해하고 유지하기 어렵게 만들기 때문에 일반적으로 권장되지 않습니다.

## 결론

이 기사에서는 Spring Boot 및 Hibernate로 트랜잭션을 사용하는 방법을 살펴보았습니다. @Transactional 어노테이션을 사용하여 트랜잭션을 구성하는 방법과 필요에 맞는 올바른 격리 수준을 선택하는 방법도 살펴보았습니다.