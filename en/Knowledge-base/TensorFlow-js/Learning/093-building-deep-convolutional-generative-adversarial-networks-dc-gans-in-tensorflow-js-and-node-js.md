---
title: 093: Building Deep Convolutional Generative Adversarial Networks (DC-GANs) in TensorFlow.js and Node.js
description: 
published: true
date: 2023-02-03T04:44:40.193Z
tags: 
editor: markdown
dateCreated: 2023-02-03T04:44:35.195Z
---

- [093: Creación de redes antagónicas generativas convolucionales profundas (DC-GAN) en TensorFlow.js y Node.js***Spanish** document is available*](/es/Knowledge-base/TensorFlow-js/Learning/093-building-deep-convolutional-generative-adversarial-networks-dc-gans-in-tensorflow-js-and-node-js)
{.links-list}
- [093：在 TensorFlow.js 和 Node.js 中构建深度卷积生成对抗网络 (DC-GAN)***Chinese Simplified** document is available*](/zh/Knowledge-base/TensorFlow-js/Learning/093-building-deep-convolutional-generative-adversarial-networks-dc-gans-in-tensorflow-js-and-node-js)
{.links-list}
- [093: TensorFlow.js 및 Node.js에서 DC-GAN(Deep Convolutional Generative Adversarial Networks) 구축***Korean** document is available*](/ko/Knowledge-base/TensorFlow-js/Learning/093-building-deep-convolutional-generative-adversarial-networks-dc-gans-in-tensorflow-js-and-node-js)
{.links-list}


# 093: Building Deep Convolutional Generative Adversarial Networks (DC-GANs) in TensorFlow.js and Node.js

Deep convolutional generative adversarial networks (DC-GANs) are a type of generative adversarial network (GAN) that are used to generate new images from a training dataset.

GANs are a type of neural network that is made up of two parts: a generator and a discriminator. The generator creates new images that are similar to the training data, while the discriminator tries to distinguish between the real training images and the fake images generated by the generator.

DC-GANs are a type of GAN that uses deep convolutional neural networks for both the generator and the discriminator.

In this tutorial, we will be using TensorFlow.js and Node.js to build a DC-GAN. We will be using the MNIST dataset, which is a dataset of handwritten digits.

## Getting Started

First, we need to install TensorFlow.js and Node.js. We can do this using the following command:

```
npm install -g @tensorflow/tfjs-node
```

Next, we need to download the MNIST dataset. We can do this using the following command:

```
wget http://yann.lecun.com/exdb/mnist/train-images-idx3-ubyte.gz
wget http://yann.lecun.com/exdb/mnist/train-labels-idx1-ubyte.gz
wget http://yann.lecun.com/exdb/mnist/t10k-images-idx3-ubyte.gz
wget http://yann.lecun.com/exdb/mnist/t10k-labels-idx1-ubyte.gz
```

We also need to uncompress the downloaded files. We can do this using the following command:

```
gunzip *
```

## Preprocessing the Data

Now that we have the MNIST dataset, we need to preprocess it so that it can be used by the DC-GAN.

First, we need to convert the images from the MNIST dataset into a format that can be used by the DC-GAN. We can do this using the following command:

```
tensorflowjs_converter --input_format=tfjs-layers-model --output_format=tfjs-layers-model --output_node_names='input,output' ./mnist_model.h5 ./tfjs_model
```

This command will convert the MNIST dataset into a format that can be used by the DC-GAN.

Next, we need to split the MNIST dataset into a training set and a test set. We can do this using the following command:

```
tensorflowjs_converter --input_format=tfjs-layers-model --output_format=tfjs-layers-model --output_node_names='input,output' --train_test_split=0.8 ./mnist_model.h5 ./tfjs_model
```

This command will split the MNIST dataset into a training set and a test set. The training set will be used to train the DC-GAN, while the test set will be used to evaluate the DC-GAN.

## Building the DC-GAN

Now that we have the MNIST dataset, we can start building the DC-GAN.

First, we need to create the generator network. The generator network will take as input a vector of noise and will generate an image that is similar to the MNIST dataset.

We can create the generator network using the following code:

```javascript
const generator = tf.sequential();

generator.add(tf.layers.dense({inputShape: [100], units: 7*7*256}));
generator.add(tf.layers.batchNormalization());
generator.add(tf.layers.leakyReLU());

generator.add(tf.layers.reshape({targetShape: [7, 7, 256]}));
generator.add(tf.layers.conv2dTranspose({
    kernelSize: 5,
    filters: 128,
    strides: 2,
    padding: 'same',
    useBias: false
}));
generator.add(tf.layers.batchNormalization());
generator.add(tf.layers.leakyReLU());

generator.add(tf.layers.conv2dTranspose({
    kernelSize: 5,
    filters: 64,
    strides: 2,
    padding: 'same',
    useBias: false
}));
generator.add(tf.layers.batchNormalization());
generator.add(tf.layers.leakyReLU());

generator.add(tf.layers.conv2dTranspose({
    kernelSize: 5,
    filters: 1,
    strides: 2,
    padding: 'same',
    useBias: false,
    activation: 'tanh'
}));
```

The generator network takes as input a vector of noise and generates an image that is similar to the MNIST dataset.

Next, we need to create the discriminator network. The discriminator network will take as input an image and will output a value that indicates whether the image is real or fake.

We can create the discriminator network using the following code:

```javascript
const discriminator = tf.sequential();

discriminator.add(tf.layers.conv2d({
    kernelSize: 5,
    filters: 64,
    strides: 2,
    padding: 'same',
    inputShape: [28, 28, 1]
}));
discriminator.add(tf.layers.leakyReLU());
discriminator.add(tf.layers.dropout({rate: 0.3}));

discriminator.add(tf.layers.conv2d({
    kernelSize: 5,
    filters: 128,
    strides: 2,
    padding: 'same'
}));
discriminator.add(tf.layers.leakyReLU());
discriminator.add(tf.layers.dropout({rate: 0.3}));

discriminator.add(tf.layers.flatten());
discriminator.add(tf.layers.dense({units: 1, activation: 'sigmoid'}));
```

The discriminator network takes as input an image and outputs a value that indicates whether the image is real or fake.

## Training the DC-GAN

Now that we have the generator and discriminator networks, we can start training the DC-GAN.

First, we need to define the loss function. The loss function is used to measure how well the DC-GAN is doing.

We can define the loss function using the following code:

```javascript
function dLoss(yTrue, yPred) {
    return tf.losses.sigmoidCrossEntropy(yTrue, yPred);
}

function gLoss(yTrue, yPred) {
    return tf.losses.sigmoidCrossEntropy(yTrue, yPred);
}
```

The loss function is used to measure how well the DC-GAN is doing.

Next, we need to define the optimizers. The optimizers are used to update the weights of the generator and discriminator networks.

We can define the optimizers using the following code:

```javascript
const dOptimizer = tf.train.RMSPropOptimizer(0.0003);
const gOptimizer = tf.train.RMSPropOptimizer(0.0001);
```

The optimizers are used to update the weights of the generator and discriminator networks.

Now, we can start training the DC-GAN. We will train the DC-GAN for 100 epochs.

We can train the DC-GAN using the following code:

```javascript
async function train() {
    for (let i = 0; i < 100; i++) {
        // Train the discriminator
        let dLosses = [];
        for (let j = 0; j < 10; j++) {
            const noise = tf.randomNormal([BATCH_SIZE, 100]);
            const generatedImages = generator.predict(noise);
            const realImages = tf.data.Dataset.fromTensorSlices(images).batch(BATCH_SIZE).take(BATCH_SIZE).toArray();
            const dRealLabels = tf.ones([BATCH_SIZE, 1]);
            const dFakeLabels = tf.zeros([BATCH_SIZE, 1]);
            const dLossReal = dLoss(dRealLabels, discriminator.predict(realImages));
            const dLossFake = dLoss(dFakeLabels, discriminator.predict(generatedImages));
            const dLoss = dLossReal + dLossFake;
            dLosses.push(dLoss);
            dOptimizer.minimize(dLoss);
        }
        const dAvgLoss = tf.mean(dLosses);
        
        // Train the generator
        const noise = tf.randomNormal([BATCH_SIZE, 100]);
        const gLabels = tf.ones([BATCH_SIZE, 1]);
        const gLoss = gLoss(gLabels, discriminator.predict(generator.predict(noise)));
        gOptimizer.minimize(gLoss);
        
        // Log the losses
        if (i % 10 === 0) {
            console.log(`Epoch: ${i}`);
            console.log(`dLoss: ${dLoss.dataSync()[0]}`);
            console.log(`gLoss: ${gLoss.dataSync()[0]}`);
        }
    }
}

train();
```

This code will train the DC-GAN for 100 epochs.

## Generating New Images

Now that the DC-GAN is trained, we can use it to generate new images.

First, we need to generate a noise vector. We can do this using the following code:

```javascript
const noise = tf.randomNormal([1, 100]);
```

Next, we need to use the generator network to generate a new image from the noise vector. We can do this using the following code:

```javascript
const generatedImage = generator.predict(noise);
```

Finally, we can visualize the generated image using the following code:

```javascript
const imageTensor = generatedImage.reshape([28, 28]);
const imageData = imageTensor.dataSync();
const canvas = document.createElement('canvas');
canvas.width = 28;
canvas.height = 28;
const ctx = canvas.getContext('2d');
const imageDataArray = Array.from(imageData);
imageDataArray.forEach((value, index) => {
    const i = Math.floor(index / 28);
    const j = index % 28;
    ctx.fillStyle = `rgb(${value}, ${value}, ${value})`;
    ctx.fillRect(j, i, 1, 1);
});
document.body.appendChild(canvas);
```

This code will generate a new image from the noise vector.

## Conclusion

In this tutorial, we have seen how to build a DC-GAN in TensorFlow.js and Node.js. We have also seen how to use the DC-GAN to generate new images.