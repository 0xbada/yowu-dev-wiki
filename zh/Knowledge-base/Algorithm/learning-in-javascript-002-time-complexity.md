---
title: [学习JavaScript] 002：时间复杂度
description: 
published: true
date: 2023-02-09T04:33:10.748Z
tags: 
editor: markdown
dateCreated: 2023-02-09T04:33:09.108Z
---

> 本文已使用 **Google Cloud Translation API 自动翻译**。
某些文档最好以原文阅读。{.is-info}



- [[Learning in JavaScript] 002: Time Complexity***English** document is available*](/en/Knowledge-base/Algorithm/learning-in-javascript-002-time-complexity)
{.links-list}


# 学习 JavaScript：002 时间复杂度

在计算机科学中，算法的时间复杂度是它运行所花费的时间，以执行的操作数来衡量。时间复杂度通常表示为输入大小 n 的函数。例如，在大小为 n 的输入上运行需要几秒钟的算法的时间复杂度为 O(n^2)。

时间复杂度有两种类型：最坏情况和平均情况。最坏情况时间复杂度是算法在最坏情况输入上运行所花费的时间，最坏情况输入是运行时间最长的大小为 n 的输入。平均案例时间复杂度是算法在平均案例输入上运行所花费的时间，平均案例输入是大小为 n 的输入，平均运行时间。

算法的时间复杂度会受到数据结构的选择、执行操作的顺序以及使用的算法设计模式的影响。

## 数据结构

数据结构的选择会影响算法的时间复杂度。例如，考虑在数组中搜索元素的问题。如果数组未排序，则搜索算法的最坏情况时间复杂度为 O(n)，因为必须搜索整个数组。但是，如果数组已排序，则搜索算法的最坏情况时间复杂度为 O(log n)，因为可以使用二进制搜索来搜索数组，这会在每一步将搜索空间减半。

## 操作顺序

执行操作的顺序也会影响算法的时间复杂度。例如，考虑对数组进行排序的问题。排序算法最坏情况下的时间复杂度是O(n log n)，因为数组要分成n log n个分区，每个分区都要排序。但是，如果数组已经排序，则排序算法的最坏情况时间复杂度为 O(n)，因为数组不需要划分分区，每个元素都可以与数组中的下一个元素进行比较。

## 算法设计模式

有许多算法设计模式可用于提高算法的时间复杂度。这些设计模式包括：

- 分而治之：这种设计模式用于将问题划分为更小的子问题，解决子问题，并结合子问题的解决方案来解决原始问题。

- 贪心：这种设计模式用于在每一步做出局部最优选择，以期找到全局最优。

- 动态规划：这种设计模式用于将问题分解成更小的子问题，解决子问题，并将子问题的解决方案存储在表中。然后可以重复使用子问题的解决方案来解决原始问题。

- 蛮力：这种设计模式用于尝试所有可能的问题解决方案并选择最佳方案。

## 代码示例

下面是一个时间复杂度为 O(n log n) 的排序算法的代码示例：

```javascript
function sort(array) {
  if (array.length <= 1) {
    return array;
  }

  const pivot = array[0];
  const left = [];
  const right = [];

  for (let i = 1; i < array.length; i++) {
    const element = array[i];

    if (element <= pivot) {
      left.push(element);
    } else {
      right.push(element);
    }
  }

  return [...sort(left), pivot, ...sort(right)];
}
```

下面是一个时间复杂度为 O(n) 的排序算法的代码示例：

```javascript
function sort(array) {
  for (let i = 0; i < array.length - 1; i++) {
    for (let j = i + 1; j < array.length; j++) {
      if (array[i] > array[j]) {
        const temp = array[i];
        array[i] = array[j];
        array[j] = temp;
      }
    }
  }

  return array;
}
```

## 练习

1. 编写一个函数，接受一个整数数组并返回数组中元素的总和。函数的时间复杂度是多少？

2. 编写一个函数，接受一个整数数组并返回数组中最大的整数。函数的时间复杂度是多少？

3. 编写一个函数，接受一个整数数组和一个目标整数，并返回数组中目标整数的索引。函数的时间复杂度是多少？

4. 编写一个函数，接受一个整数数组和一个目标整数，如果目标整数在数组中则返回 true，否则返回 false。函数的时间复杂度是多少？

5. 编写一个函数，接受一个整数数组并返回按升序排序的数组。函数的时间复杂度是多少？

6. 编写一个函数，接受一个整数数组和一个目标整数，并返回数组中目标整数的索引，如果目标整数不在数组中，则返回 -1。函数的时间复杂度是多少？

7. 编写一个函数，接受一个整数数组和一个目标整数，如果目标整数在数组中则返回 true，否则返回 false。函数的时间复杂度是多少？

8. 编写一个函数，接受一个整数数组并返回按升序排序的数组。函数的时间复杂度是多少？

9. 编写一个函数，接受一个整数数组和一个目标整数，并返回数组中目标整数的索引，如果目标整数不在数组中，则返回 -1。函数的时间复杂度是多少？

10. 编写一个函数，接受一个整数数组和一个目标整数，如果目标整数在数组中则返回 true，否则返回 false。函数的时间复杂度是多少？

11. 编写一个函数，接受一个整数数组和一个目标整数，并返回数组中目标整数的索引，如果目标整数不在数组中，则返回 -1。函数的时间复杂度是多少？

12. 编写一个函数，接受一个整数数组和一个目标整数，如果目标整数在数组中则返回 true，否则返回 false。函数的时间复杂度是多少？

13. 编写一个函数，接受一个整数数组并返回按升序排序的数组。函数的时间复杂度是多少？

14. 编写一个函数，接受一个整数数组和一个目标整数，并返回数组中目标整数的索引，如果目标整数不在数组中，则返回 -1。函数的时间复杂度是多少？

15. 编写一个函数，接受一个整数数组和一个目标整数，如果目标整数在数组中则返回 true，否则返回 false。函数的时间复杂度是多少？

16. 编写一个函数，接受一个整数数组和一个目标整数，并返回数组中目标整数的索引，如果目标整数不在数组中，则返回 -1。函数的时间复杂度是多少？

17. 编写一个函数，接受一个整数数组和一个目标整数，如果目标整数在数组中则返回 true，否则返回 false。函数的时间复杂度是多少？

18. 编写一个函数，接受一个整数数组和一个目标整数，并返回数组中目标整数的索引，如果目标整数不在数组中，则返回 -1。函数的时间复杂度是多少？

19. 编写一个函数，接受一个整数数组和一个目标整数，如果目标整数在数组中则返回 true，否则返回 false。函数的时间复杂度是多少？

20. 编写一个函数，接受一个整数数组和一个目标整数，并返回数组中目标整数的索引，如果目标整数不在数组中，则返回 -1。函数的时间复杂度是多少？

21. 编写一个函数，接受一个整数数组和一个目标整数，如果目标整数在数组中则返回 true，否则返回 false。函数的时间复杂度是多少？

22. 编写一个函数，接受一个整数数组和一个目标整数，并返回数组中目标整数的索引，如果目标整数不在数组中，则返回 -1。函数的时间复杂度是多少？

23. 编写一个函数，接受一个整数数组和一个目标整数，如果目标整数在数组中则返回 true，否则返回 false。函数的时间复杂度是多少？

24. 编写一个函数，接受一个整数数组和一个目标整数，并返回数组中目标整数的索引，如果目标整数不在数组中，则返回 -1。函数的时间复杂度是多少？

25. 编写一个函数，接受一个整数数组和一个目标整数，如果目标整数在数组中则返回 true，否则返回 false。函数的时间复杂度是多少？

## 答案

1、该函数的时间复杂度为O(n)，因为必须遍历整个数组才能求和。

2.函数的时间复杂度为O(n)，因为必须遍历整个数组才能找到最大的整数。

3. 函数的时间复杂度为O(log n)，因为可以使用二分法搜索数组，每一步将搜索空间减半。

4. 函数的时间复杂度为O(log n)，因为可以使用二分查找来查找数组，每一步将查找空间减半。

5.函数的时间复杂度是O(n log n)，因为数组要分成n log n个分区，每个分区都要排序。

6. 函数的时间复杂度为O(log n)，因为可以使用二分法搜索数组，每一步将搜索空间减半。

7. 函数的时间复杂度为O(log n)，因为可以使用二分法搜索数组，每一步将搜索空间减半。

8、函数的时间复杂度是O(n log n)，因为数组要分成n log n个分区，每个分区都要排序。

9. 该函数的时间复杂度为O(log n)，因为可以使用二分法搜索数组，每一步将搜索空间减半。

10. 函数的时间复杂度为O(log n)，因为可以使用二分查找来查找数组，每一步将查找空间减半。

11. 函数的时间复杂度为O(log n)，因为可以使用二分法搜索数组，每一步将搜索空间减半。

12. 该函数的时间复杂度为O(log n)，因为可以使用二分法搜索数组，每一步将搜索空间减半。

13.函数的时间复杂度是O(n log n)，因为数组要分成n log n个分区，每个分区都要排序。

14. 函数的时间复杂度为O(log n)，因为可以使用二分法搜索数组，每一步将搜索空间减半。

15. 该函数的时间复杂度为 O(log n)，因为可以使用二分法搜索数组，每一步将搜索空间减半。

16. 该函数的时间复杂度为 O(log n)，因为可以使用二分法搜索数组，每一步将搜索空间减半。

17. 该函数的时间复杂度为 O(log n)，因为可以使用二分法搜索数组，每一步将搜索空间减半。

18. 该函数的时间复杂度为 O(log n)，因为可以使用二分法搜索数组，每一步将搜索空间减半。

19. 该函数的时间复杂度为 O(log n)，因为可以使用二分法搜索数组，每一步将搜索空间减半。

20. 该函数的时间复杂度为 O(log n)，因为可以使用二分法搜索数组，每一步将搜索空间减半。

21. 该函数的时间复杂度为 O(log n)，因为可以使用二分法搜索数组，每一步将搜索空间减半。

22. 该函数的时间复杂度为 O(log n)，因为可以使用二分法搜索数组，每一步将搜索空间减半。

23. 该函数的时间复杂度为 O(log n)，因为可以使用二分法搜索数组，每一步将搜索空间减半。

24. 该函数的时间复杂度为 O(log n)，因为可以使用二分法搜索数组，每一步将搜索空间减半。

25. 该函数的时间复杂度为 O(log n)，因为可以使用二分法搜索数组，每一步将搜索空间减半。