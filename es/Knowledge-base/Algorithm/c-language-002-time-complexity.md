---
title: [Lenguaje C] 002: Complejidad del tiempo
description: 
published: true
date: 2023-02-09T08:17:33.512Z
tags: 
editor: markdown
dateCreated: 2023-02-09T08:17:27.468Z
---

> Esta página se **tradujo automáticamente con la API de traducción de Google Cloud**.
Algunas páginas se pueden leer mejor en su totalidad.{.is-info}



- [[C Language] 002: Time Complexity***English** document is available*](/en/Knowledge-base/Algorithm/c-language-002-time-complexity)
{.links-list}


# Lenguaje C: 002 Complejidad de tiempo

En informática, la complejidad temporal de un algoritmo cuantifica la cantidad de tiempo que tarda un algoritmo en ejecutarse en función de la longitud de la entrada. La complejidad del tiempo comúnmente se estima contando el número de operaciones elementales realizadas por el algoritmo, donde una operación elemental requiere una cantidad fija de tiempo para realizarse. Por lo tanto, la cantidad de tiempo que tarda el algoritmo es, como máximo, un múltiplo constante del número de operaciones elementales.

La complejidad temporal de un algoritmo a menudo se expresa como una función T(n), donde n es la longitud de la entrada. Por ejemplo, si la complejidad temporal de un algoritmo es T(n) = 2n^2 + 5n + 10, entonces, a medida que aumenta el tamaño de entrada n, el tiempo que tarda el algoritmo aumenta cuadráticamente.

Hay dos formas comunes de expresar la complejidad del tiempo: la notación asintótica y la complejidad del tiempo exacto.

La notación asintótica es una notación matemática que describe el comportamiento límite de una función cuando el argumento tiende a infinito. Los tipos más comunes de notación asintótica son la notación Big O, la notación Big Ω y la notación Big Θ.

La complejidad del tiempo exacto es una notación matemática que describe la cantidad exacta de tiempo que tarda un algoritmo en ejecutarse en función de la longitud de la entrada.

Las funciones comunes de complejidad de tiempo son:

* Constante: T(n) = c
* Logarítmico: T(n) = log(n)
* Lineal: T(n) = n
* Log-lineal: T(n) = nlog(n)
* Cuadrática: T(n) = n^2
* Cúbico: T(n) = n^3
* Exponencial: T(n) = 2^n

La complejidad temporal de un algoritmo puede verse afectada por la elección de las estructuras de datos. Por ejemplo, la complejidad temporal de un algoritmo de ordenación puede ser diferente dependiendo de si la entrada es una matriz o una lista enlazada.

La complejidad temporal de un algoritmo también se ve afectada por la elección de los algoritmos. Por ejemplo, la complejidad temporal de un algoritmo de clasificación puede ser diferente dependiendo de si el algoritmo es una clasificación de comparación o una clasificación sin comparación.

La complejidad temporal de un algoritmo también se ve afectada por la elección de la implementación. Por ejemplo, la complejidad temporal de un algoritmo de clasificación puede ser diferente dependiendo de si la implementación está en un lenguaje de alto o bajo nivel.

La complejidad temporal de un algoritmo también se ve afectada por la elección del hardware. Por ejemplo, la complejidad temporal de un algoritmo de clasificación puede ser diferente dependiendo de si el hardware es una computadora de propósito general o una computadora de propósito especial.

La complejidad temporal de un algoritmo también se ve afectada por la elección del sistema operativo. Por ejemplo, la complejidad temporal de un algoritmo de clasificación puede ser diferente dependiendo de si el sistema operativo es un sistema operativo multitarea o un sistema operativo de una sola tarea.

La complejidad temporal de un algoritmo también se ve afectada por la elección del compilador. Por ejemplo, la complejidad temporal de un algoritmo de clasificación puede ser diferente dependiendo de si el compilador es un compilador optimizador o un compilador no optimizador.

La complejidad temporal de un algoritmo también se ve afectada por la elección de las bibliotecas. Por ejemplo, la complejidad temporal de un algoritmo de clasificación puede ser diferente dependiendo de si la biblioteca es la biblioteca de plantillas estándar o la biblioteca Boost.

La complejidad temporal de un algoritmo también se ve afectada por la elección de la arquitectura de la computadora. Por ejemplo, la complejidad temporal de un algoritmo de clasificación puede ser diferente dependiendo de si la arquitectura de la computadora es una arquitectura de von Neumann o una arquitectura de Harvard.

La complejidad temporal de un algoritmo también se ve afectada por la elección del tamaño de caché. Por ejemplo, la complejidad temporal de un algoritmo de ordenación puede ser diferente dependiendo de si el tamaño de la memoria caché es pequeño o grande.

La complejidad temporal de un algoritmo también se ve afectada por la elección del tamaño de la memoria principal. Por ejemplo, la complejidad temporal de un algoritmo de ordenación puede ser diferente dependiendo de si el tamaño de la memoria principal es pequeño o grande.

La complejidad temporal de un algoritmo también se ve afectada por la elección del tamaño de la memoria virtual. Por ejemplo, la complejidad temporal de un algoritmo de ordenación puede ser diferente dependiendo de si el tamaño de la memoria virtual es pequeño o grande.

La complejidad temporal de un algoritmo también se ve afectada por la elección del tamaño del disco. Por ejemplo, la complejidad temporal de un algoritmo de ordenación puede ser diferente dependiendo de si el tamaño del disco es pequeño o grande.

La complejidad temporal de un algoritmo también se ve afectada por la elección del tamaño de la red. Por ejemplo, la complejidad temporal de un algoritmo de clasificación puede ser diferente según el tamaño de la red sea pequeño o grande.

La complejidad temporal de un algoritmo también se ve afectada por la elección del tamaño de entrada. Por ejemplo, la complejidad temporal de un algoritmo de ordenación puede ser diferente dependiendo de si el tamaño de entrada es pequeño o grande.

La complejidad temporal de un algoritmo también se ve afectada por la elección del tamaño de salida. Por ejemplo, la complejidad temporal de un algoritmo de ordenación puede ser diferente dependiendo de si el tamaño de salida es pequeño o grande.

La complejidad temporal de un algoritmo también se ve afectada por la elección del número de procesadores. Por ejemplo, la complejidad temporal de un algoritmo de clasificación puede ser diferente dependiendo de si el número de procesadores es pequeño o grande.

La complejidad temporal de un algoritmo también se ve afectada por la elección del tamaño de palabra. Por ejemplo, la complejidad temporal de un algoritmo de ordenación puede ser diferente dependiendo de si el tamaño de la palabra es pequeño o grande.

La complejidad temporal de un algoritmo también se ve afectada por la elección de la velocidad del reloj. Por ejemplo, la complejidad temporal de un algoritmo de clasificación puede ser diferente dependiendo de si la velocidad del reloj es lenta o rápida.

La complejidad temporal de un algoritmo también se ve afectada por la elección de los dispositivos de E/S. Por ejemplo, la complejidad temporal de un algoritmo de ordenación puede ser diferente dependiendo de si los dispositivos de E/S son lentos o rápidos.